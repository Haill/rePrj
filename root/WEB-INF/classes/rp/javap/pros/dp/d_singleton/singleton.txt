单例模式(Singleton)
5.1.1读取配置文件的内容
	考虑这样一个应用，读取配置文件的内容
	很多应用项目，都有与应用相关的配置文件，这些配置文件很多是由项目开发人员自定义的，在里面定义一些应用需要的参数数据。
	properties
	
	现在要读取配置文件的内容，该如何实现呢？

5.1.2不用模式的解决方案
	有些朋友会想，要读取配置文件的内容，这也不是个困难的事情，直接读取文件的内容，然后把文件的内容存放在对象里面就可以了。
	
5.1.3有何问题
	看看客户端使用这个类的地方，是通过new一个AppConfig的实例来得到一个操作配置文件内容的对象。
	如果在系统运行中，有很多地方都需要使用配置文件的内容，也就说很多地方都需要创建AppConfig对象的实例。
	
	当然有问题了，试想一下，每一个AppConfig实例对象里面都封装着配置文件的内容，
	系统中有多个AppConfig实例对象，也就是说系统中同时存在多份配置文件的内容，这样会严重浪费内存资源。
	如果配置文件内容较少，问题还小一点，如果配置文件内容本来就多的话，对于系统资源的浪费问题就大了。事实上，
	对于AppConfig这种类，在运行期间，只需要一个实例对象就是够了。
		
	把上面的描述进一步抽象一下，问题就出来了：在一个系统运行期间，某个类只需要一个类实例就可以了，
	那么应该怎样实现呢？
	
5.2.1
1.单例模式的定义
	保证一个类仅有一个实例，并提供一个访问它的全局访问点。

2.应用单例模式来解决问题的思路
	仔细分析上面的问题，现在一个类能够被创建多个实例，问题的根源在于类的构造方法是公开的，
	也就是可以让类的外部来通过构造方法创建多个实例。换句话说，
	只要类的构造方法能让类的外部访问，就没有办法去控制外部来创建这个类的实例个数。
	
	要想控制一个类只被创建一个实例，那么首要的问题就是要把创建实例的权限收回，
	让类自身来负责自己类实例的创建工作，然后由这个类来提供外部可以访问这个类实例的方法，
	这就似乎单例模式的实现方式。
	
	
5.2.2单例模式的结构和说明

5.2.3单例模式示例代码
	在Java中，单例模式的实现又分为两种，一种称为懒汉式，一种称为饿汉式，
	其实就是在具体创建对象实例的处理上，有不同的实现方式。
	
	所谓饿汉式，既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，
	于是就在装载类的时候就创建对象实例，
	private static Singleton uniqueInstance = new Singleton();
	
	所谓懒汉式，既然是懒，那么在创建对象实例的时候就不着急，会一直等到马上要使用对象实例的时候才会创建，
	懒人嘛，总是推托不开的时候才去执行工作，因此在装载对象的时候不创建对象实例，
	private static Singleton uniqueInstance = null;
	
5.3.1 认识单例模式
1.单例模式的功能
	单例模式是用来保证这个类在运行期间只会被创建一个类实例，
	另外，单例模式还提供了一个全局唯一访问这个类实例的访问点，就是getInstance方法。
	
	对于单例模式而言，不管采用何种实现方式，他都是只关心类实例的创建问题，并不关心具体的业务功能。
	
2.单例模式的范围
	也就是在多大范围内是单例呢？
	观察上面的实现可以知道，目前Java里面实现的单例是一个虚拟机的范围。
	因为装载类的功能是虚拟机的，所以一个虚拟机在通过自己的ClassLoader装在饿汉式实现单例类的时候
	就会创建一个类的实例。
	
	这就意味着如果一个虚拟机里面有很多个ClassLoader,而且这些ClassLoader都装载某个类的话，
	就算这个类是单例，它也会产生很多个实例。
	
	把获取实例的方法变成静态的
	又有新的问题了，获取对象实例的这个方法是一个实例方法，也就是说客户端要想调用这个方法，需要先得到类实例，
	然后才可以调用。可是这个方法就是为了得到类实例，这样一来不就形成了一个死循环了吗？								
	
5.3.3 延迟加载的思想
	单例模式的懒汉式实现方式体现了延迟加载的思想。
	这在实际的开发中是一种很常见的思想，尽可能地节约资源。

5.3.4 缓存的思想
	单例模式的懒汉式实现方式还体现了缓存的思想。
	缓存是一种典型的空间换时间的方案

5.3.5 Java中缓存的基本实现
	下面来看看在Java开发中缓存的基本实现，在Java开发中最常用的一种实现换成的方式就是使用Map,
	基本步骤如下。
	(1)先到缓存里面查找，看看是否存在需要使用的数据。
	(2)如果没有找到，那么就创建一个瞒着要求的数据，然后把这个数据设置到缓存中，以备下次使用。
	    如果找到了相应的数据，或者是创建了相应的数据，那就直接使用这个数据。

    			
5.3.7 单例模式的优缺点
1.时间和空间
	比较上面两种写法:
	懒汉式是经典的时间换空间，
	饿汉式是经典的空间换时间。

双重检查枷锁
	可以使用“双重检查枷锁”的方式来实现，就可以既实现线程安全，有能使性能不受到很大的影响。
	
	所谓双重检查枷锁机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，
	进入方法过后，先检查视力是否存在，如果不存在才进入下面的同步快，
	这是第一重检查。进入同步快过后，再次检查视力是否存在，如果不存在，就在同步的情况下创建一个实例，
	这是第二重检查。
	这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。
	
	双重检查枷锁机制的实现会使用一个关键字volatile,他的意思是：被volatile修饰的变量的值，
	将不会iubei本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。
	
线程安全问题：
	饿汉式是线程安全的，因为虚拟机保证只会装载一次，在装载类的时候是不会并发的。
	
	如何实现懒汉式的线程安全呢？
	当然懒汉式也是可以实现线程安全的，只要加上synchronized即可，
	public static synchronized Singleton getInstance(){}
	但是这样一来，会降低整个访问的速度，而且每次都要判断。
	
	双重检查枷锁
	
	所谓双重检查加锁机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，
	先检查实例方法是否存在，如果不存在才进入下面的同步快，
	
	进入同步快过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，
	
	这样一来，就只需同步一次了，从而减少了多次在同步情况下进行判断浪费的时间。
	
	双重检查加锁机制的实现会使用一个关键字volatile,它的意思是：
	被volatile修饰的变量，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的
	处理该变量。
	
2.何时选用单例模式
	当需要控制一个类的实例只能有一个，而且客户只能从一个全局访问点访问它时，可以选用单例模式，	
	
	
	
	
