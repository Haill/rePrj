1.外观模式的定义：
	为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，
	这个接口使得这一子系统更加容易使用。
	
	界面，
		一提到界面，估计很多朋友的第一反应就是图形界面(GUI).其实在这里提高的界面，
	主要指的是从一个组件外部来看这个组件，能够看到什么，这就是这个组件的界面，也就是所说的外观。
		比如，你从一个类的外部来看这个类，那么这个类的public方法就是这个类的外观，
	因为你从类外部来看这个类，就能看到这些。
	
	接口
		一提到接口，做Java的朋友的第一个反应就是interface.其实在这里提到的接口，
	主要指的是外部和内部交互的这么一个通道，通常是指一些方法，可以使类的方法，也可以是interface的方法。
	也就是说，这里所说的接口，并不等价于interface，也有可能是个类。

2.使用外观模式来解决问题的思路
		仔细分析上面的问题，客户端想要操作更简单点，那就根据客户端的需要来给客户端定义一个简单的接口，然后让客户端调用这个接口，
	剩下的事情客户端就不用管他，这样客户端就变得简单了。
		当然，这里所说的接口就是客户端和被访问的系统之间的一个通道，并不一定是指Java的interface。它在外观模式里面，通常指的是类，
	这个类被称为“外观”。
		外观模式就是通过映入这么一个外观类，在这个类里定义客户端想要的简单的方法，然后再这些方法的实现里面，
	由外观类再去分别调用内部的多个模块来实现功能，从而让客户端变得简单。这样一来，客户端就只需要和外观类交互就可以了。

3.认识外观模式
		外观模式的目的不是给子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦合，
	从而让外部能够更简单地使用子系统。
	
		这点要特别注意，因为外观是当作子系统对外的接口出现的，虽然也可以在这里定义一些子系统没有的功能，
	但不建议这么做。外观应该是包装已有的功能，他主要负责组合已有功能来实现客户需求，而不是添加新的实现。

3.3.2 外观模式的实现
	1.	对于一个子系统而言，外观类不需要很多，通常可以实现成一个单例。
		也可以直接把外观中的方法实现成静态的方法，这样可以不需要创建外观对象的实例而直接调用，
	这种实现相当于把外观类当成一个辅助工具类实现。
	
	2.Facade可以实现成为interface
		虽然Facade通常直接实现成为类，但是也可以把Facade实现成为真正的interface.
	只是这样会增加系统的复杂程度，因为这样会需要一个Facade的实现，而需要一个来获取Facade接口对象的工厂。
		如果把Facade实现成为接口，还附带一个功能，就是能够有选择性地暴露接口的方法，尽量减少对系统外提供的接口方法。
		
	4.Facade的方法实现
		Facade的方法实现中，一般是负责把客户端的请求转发给子系统内部的各个模块进行处理，Facade的方法本身并不进行功能的处理，
	Facade的方法实现只是实现一个功能的组合调用。
		当然在Facade中实现一个逻辑处理也并不是不可以的，但是不建议这样做，因为这不是Facade的本意，也超出了Facade的边界。

思考外观模式
	外观模式的本质是：封装交互，简化调用。
	
	Facade封装了子系统外部和子系统内部多个模块的交互过程，从而简化了外部的调用。
	通过外观，子系统为外部提供一些高层的接口，以方便他们的使用。
			
相关模式		
1.外观模式和中介者模式
	这两个模式非常类似，但是却有本质的区别。
	中介者模式主要用来封装多个对象之间相互的交互，用在系统内部的多个模块之间;
	而外观模式封装的是单向的交互，是从客户端访问系统的调用，没有从系统中来访问客户端的调用。
	
	在中介者模式的实现里面，是需要实现具体的交互功能的;
	而外观模式的实现里面，一般是组合调用或是转调内部实现的功能，通常外观模式本身并不实现这些功能。
	
	中介者模式的目的主要是松散多个模块之间的耦合，把这些耦合关系全部放到中介者中去实现;而外观模式的目的是简化客户端的调用，
	这点和中介者模式也不同。
	
2.外观模式和单例模式
	通常一个子系统只需要一个外观实例,所以外观模式可以和单例模式组合使用，
	把Facade类实现成为单例。当然，也可也跟前面示例的那样，把外观类的构造方法私有化，
	然后把提供给客户段的方法实现成为静态的。

3.外观模式和抽象工厂模式
	外观模式的外观类通常需要和系统的多个模块交互，每个模块一般都有自己的接口，
	所以在外观类的具体实现里面，需要获取这些接口，然后组合这些接口来完成客户端的功能。
	
	那么怎么获取这些接口呢？ 就可以和抽象工厂一起使用，外观类通过抽象工厂来获取所需要的接口，
	而抽象工厂也可以把模块内部的实现对Facade进行屏蔽，也就是Facade也仅仅是知道它从模块中获取他需要的功能，
	模块内部的细节，Facade也不知道。
		


























	
		
	