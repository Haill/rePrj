抽象工厂模式(Abstract Factory)
7.1.1选择组装电脑的配件
	选择不同的CPU和主板，是每个客户在组装电脑的时候，向装机公司提出的要求。
	也就是我们每个人自己拟定的装机方案。
	装机方案是有整体性的，里面选择的各个配件之间是有关联的。
	
	当装机工程师为不同的客户组装电脑时，只需要按照客户的装机方案，去获取相应的配件，然后组装即可。
	
	现在需要使用程序来把这个装机的过程，尤其是选择组装电脑配件的过程实现出来，该如何实现呢？

7.1.2 不用模式的解决方案
	对装机工程师而言，只是知道CPU和主板的接口，而不知道具体实现，
	很明显可以用上简单工厂或工厂方法模式。
	为了简单，这里选用简单工厂。
	客户告诉装机工程师自己的选择，
	然后装机工程师会通过相应的工厂去获取相应的实例对象。
		
7.1.3 有何问题
	看了上面的实现，会感觉到很简单，通过使用简单工厂来获取需要的CPU和主板对象，
	然后就可以组装电脑了，
	上面的实现，虽然通过简单工厂解决了：
		对于装机工程师，只知CPU和主板的接口，而不知道具体实现的问题。
	但还有一个问题没有解决，什么问题呢？
	那就是这些CPU对象和主板对象其实是有关系的，是需要相互匹配的。
	
	而在上面的实现中，并没有维护这种关联关系，CPU和主板是由客户随意选择的。这是有问题的。
	
7.2 解决方案
7.2.1 使用抽象工厂模式来解决问题
	1.抽象工厂模式的定义
		提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
	2.应用抽象工厂模式来解决问题的思路
		仔细分析上面的问题，其实有两个问题点，
		一个是只知道所需的一系列对象的接口，而不知具体实现，或者是不知道具体使用哪一个实现；
		另外一个是这一系列对象是相关或者相互依赖的，也就是说既要创建接口的对象，还要约束他们之间的关系。
		
		这里要解决的问题是，要创建一系列的产品对象，而且这一系列对象是构成新的对象所需要的组成部分，
		也就是这一系列被创建的对象相互之间是有约束的。
		
		解决这个问题的一个解决方案就是抽象工厂模式。
		在这个模式里面，会定义一个抽象工厂，在里面虚拟地创建客户端需要的这一系列对象，
		所谓虚拟的就是定义创建这些对象的抽象方法，并不去真正地实现，
		然后由具体的抽象工厂的子类来提供这一系列对象的创建。
		这样一来可以为同一抽象工厂提供很多不同的实现，那么创建的这一系列对象也就不一样了，
		也就是说，抽象工厂在这里起到一个约束的作用，
		并提供所有子类的一个统一外观，来让客户端使用。
		
7.2.2 抽象工厂模式的结构和说明
	Abstract Factory：抽象工厂，定义创建一系列产品对象的操作接口。
	Concrete Factory：具体的工厂，实现抽象工厂定义的方法，具体实现一系列产品对象的创建。
	Abstract Product：定义一类产品对象的接口。
	Concrete Product：具体的产品是实现对象，通常在具体工厂里面，会选择具体的产品实例对象，
					  来创建符合抽象工厂定义的方法返回的产品类型的对象。
	Client：客户端，主要使用抽象工厂来获取一系列所需要的产品对象，然后面向这些产品对象的接口编程，以实现需要的功能。

7.2.3 抽象工厂模式示例代码
							
7.2.4 使用抽象工厂模式重写示例
	要使用抽象工厂模式来重写案例，先来看看如何使用抽象工厂模式来解决前面提出的问题。
	
	装机工程师要组装电脑对象，需要一系列的产品对象，比如CPU、主板等，
	于是创建一个抽象工程给装机工程师使用，
	在这个抽象工厂里面   定义  抽象地  创建CPU和主板的方法，
	这个抽象的工厂就相当于一个抽象的装机方案，
	在这个装机方案里面，各个配件是能够相互匹配的。
	
	每个装机的客户，会提出他们自己的具体装机方案，
	或者是选择已有的装机方案，
	相当于为抽象工厂提供了具体的子类，在这些具体的装机方案里面，
	会创建具体的CPU和主板实现对象。
	
	虽然说是重写示例，但并不是前面写的都不要了，而是修改前面的示例，使它能更好滴
	实现需要的功能。
	
	(1)前面示例实现的CPU接口和CPU实现对象，还有主板的接口和实现对象，都不需要变化，这里就不再赘述了。
	(2)前面示例中创建CPU的简单工厂和创建主板的简单工厂，都不再需要了，直接删除即可，这里就不去管它了。
	(3)看看新加入的抽象工厂的定义。示例代码如下:
	(4)再看看抽象工厂的实现对象，也就是具体的装机方法对象。
	(5)下面来看看装机工程师类的实现。
		在现在的实现里面，装机工程师相当于使用抽象工厂的的客户端，
		虽然是由真正的客户来选择和创建具体的工厂对象，
		但是使用抽象工厂的是装机工程师对象。
		
		装机工程师类跟前面的实现相比，主要的变化是：
		从客户端不再传人选择CPU和主板的参数，
		而是直接传入客户选择并创建好的装机方案对象。	
		这样就避免了单独去选择CPU和主板，
		客户要选就是一套，就是一个系列。
		示例代码如下：		
	
7.3.2 定义可扩展的工厂
	在前面的示例中，抽象工厂为每一种它能创建的产品对象定义了相应的方法，
	比如创建CPU的方法和创建主板的方法
	
	这种实现有一个麻烦，就是如果在产品簇中要新增加一种产品，
	比如现在要求抽象工厂除了能够创建CPU和主板外，还要能够创建内存对象，
	那么就需要在抽象工厂里面添加创建内存的一个方法。
	当抽象工厂一发生变化，所有的具体的工厂实现都要发生变化， 
	如下，如此就非常的不灵活。
	
	现在有一种相对灵活，但不太安全的改进方式就可以解决这个问题，
	思路如下:
		抽象工厂里面不需要定义那么多方法，定义一个方法就可以了，给这个方法设置一个参数，
	通过这个参数来判断具体创建什么产品对象；
	由于只有一个方法，在返回类型上就不能是具体的某个产品类型了，
	只能是所有的产品对象都继承或者实现的这么一个类型，
	比如让所有的产品都实现某个接口，或者干脆使用Object类型。
		
7.3.3 抽象工厂模式和DAO
	1.什么是DAO
		DAO：数据访问对象，是Data Access Object首字母的简写
		DAO是JavaEE中的一个标准模式，
		通过它来解决访问数据对象所面临的一系列问题，
		比如，数据源不同，存储类型不同，访问方式不同，供应商不同，版本不同等，
		这些不同会造成访问数据的实现上差别很大。
		
		但是对于需要进行数据访问的逻辑而言，它可不想面对这么多不同，也不想处理这么多差异，
		它希望能以一个统一的方式来访问数据。
		
		也就是说，DAO需要抽象和封装所有对数据的访问，DAO承担和数据仓库交互的职责，
		这也意味着，访问数据所面临的所有问题，都需要DAO在内部来自自行解决。
	
	2.DAO和抽象工厂的关系
		事实上，在实现DAO模式的时候，最常见的实现策略就是使用工厂的策略，
		而且多是通过抽象工厂模式来实现，
		当然在使用抽象工厂模式来实现的时候，可以结合工厂方法模式。
		因此DAO模式和抽象工厂模式有很大的联系。
		
	3.DAO模式的工厂实现策略
		下面就来看看DAO模式实现的时候是如何采用  工厂方法 和 抽象工厂的。
		1）采用工厂方法模式
			假如现在在一个订单处理的模块里面。
			大家都知道，订单通常分成两个部分，
			一部分是订单主记录或者是订单主表，另一部分是订单明细记录或者订单字表，
			那么现在业务对象需要操作订单的主记录，也需要操作订单的子记录。
			
			如果这个时候的业务比较简单，而且对数据的操作时固定的，比如就是操作数据库，
			不管订单的业务如何变化，底层数据存储都是一样的，那么这种情况下，可以采用工厂方法模式，
			
			如果顶层存储固定的时候，DAOFactory就相当于工厂方法模式中的Creator,
			在里面定义工厂方法，分别创建订单主记录的DAO对象和创建订单子记录的DAO对象，
			因为固定是数据库实现，因此提供一个具体的工厂RdbDAOFacory来实现对象的创建。
			也就是说DAO可以采用工厂方法模式来实现。
			
			采用工厂方法模式的情况，要求DAO底层存储实现方式是固定的，这种模式多用在一些简单的小项目的开发上。
			
		2)采用抽象工厂模式
			实际上更多的时候DAO底层存储实现方式是不固定的，
			DAO通常会支持多种存储实现方式，
			具体使用哪一种存储方式可能是由应用动态决定， 
			或者是通过配置来指定。
			
			这种情况多见于产品开发，或者是稍复杂的应用、亦或较大的项目中。
			
			
			从上面的结构示意图可以看出，采用抽象工厂模式来实现DAO的时候，DAOFactory
			就相当于抽象工厂，里面定义一系列创建相关对象的方法，
			分别是创建订单主记录的DAO对象和创建订单子记录的DAO对象，
			此时OrderMainDAO和OrderDetailDAO就相当于被创建的产品，
			RdbDAOFactroy和XmlDAOFactory就相当于抽象工厂的具体实现，
			在他们里面会选择相应的具体的产品实现来创建对象。
			
		4.代码示例使用抽象工厂实现DAO模式

7.3.4 抽象工厂模式的优缺点
	抽象工厂模式的优点
		1)分离接口和实现
			客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，
			客户端只是面向产品的接口编程而已。
			也就是说，客户端从具体的产品实现中解耦。
		2)使得切换产品簇变得容易
		
	抽象工厂模式的缺点 
		1)不太容易扩展新的产品
			
		2)容易造成类层次复杂
			抽象工厂的实现也需要分出层次来，每一层负责一种选择，也就是一层屏蔽一种变化，
			这样很容易造成负责的类层次结构。

7.3.5 思考抽象工厂模式
	抽象工厂模式的本质:选择产品簇的实现。
	1)抽象工厂模式的本质
		工厂方法是选择单个产品的实现，虽然一个类里面可以有多个工厂方法，
		但是这些方法之间是没有联系的，即使看起来像有联系。
		
		但是抽象工厂着重的就是为一个产品簇选择实现，定义在抽象工厂里面的方法通常是由联系的，
		它们都是产品的某一部分或者是相互依赖的。
		如果抽象工厂里面只定义一个方法，直接创建产品，那么就退化成为工厂方法了。
		
	2)何时选用抽象工厂模式
		a.希望一个系统只是知道产品的接口，而不关心实现的时候。
		b.可以动态地切换产品簇的时候。
		d.如果强调一系列相关产品的接口，以便联合使用它们的时候。
		
	在抽象工厂模式里面，具体的工厂实现，在整个应用中，
	通常一个产品系列之需要一个实例就可以了，
	因此可以把具体的工厂实现成为单例。
				
	
	
	
	
	
	
	
	
	