有何问题

	分析上面要实现的应用框架，不管用户选择什么样的导出格式，最后导出的都是一个文件，
	而且系统并不知道究竟导出成什么样的文件，因此应该有一个统一的接口来描述系统最后的对象，并操作输出的文件
	
	先把导出的文件对象的接口定义出来，
	
	
	对于实现导出数据的功能对象，他应根据需要来创建相应的ExportFileApi的实现对象，
	因为特定的ExportFileApi的实现是与具体的业务相关的。但是对于实现导出数据的业务功能对象而言，
	它并不知道应该创建哪一个ExportFileApi的实现对象，也不知道如何创建。
	
	也就是说：对于实现导出数据的业务功能对象，它需要创建ExportFileApi的具体事例对象，但是它只知道ExportFileApi接口，
	而不知道其具体的实现，那该怎么办呢？
	
	也就是说：对于实现导出数据的业务功能对象，它需要创建ExportFileApi的具体事例对象，但是它只知道ExportFileApi接口，
	而不知道其具体的实现，那该怎么办呢？
	
6.2.1使用工厂方法模式来解决问题
	用来解决上述问题的一个合理的解决方案就是工厂方法模式（Factory Method）。
	
	1.工厂方法模式的定义
		定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使
		一个类的实例化延迟到其子类。
	
	2.应用工厂方法模式来解决问题的思路
		仔细分析上面的问题，事实上在实现导出数据的业务功能对象里面，根本就不知道究竟要使用哪一种导出文件的格式
		因此这个对象根本就不应该和具体的导出文件的对象耦合在一起，
		它只需要面向导出的文件对象的接口就可以了。
		
		但是这样一来，又有新的问题产生了:接口是不能直接使用的，需要使用具体的接口实现对象的实例。
		
		这不是自相矛盾吗？要求面向接口，不让和具体的实例耦合，但是又需要创建接口的具体实现对象的实例。
		怎么解决这个矛盾呢？
		
		工厂方法模式的解决思路很有意思，那就是不解决，采取无为而治的方式：
		不是需要接口对象吗，那就定义一个方法来创建；可是事实上他自己是不知道如何创建这个接口对象的，
		没有关系，定义成抽象方法就可以了，自己实现不了，那就让子类来实现，
		这样这个对象本身就可以只是面向接口编程，而无需关心到底如何创建接口对象了。
		
		
6.2.2 工厂方法模式的结构和说明
	Product:定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口。
	ConcreteProduct:具体的Product接口的实现对象。
	Creator:创建器，声明工厂方法，工厂方法通常会返回一个Product类型的实例对象，
			而且多是抽象方法。也可以在Creator里面提供工厂方法的默认实现，
			让工厂方法返回一个缺省的Product类型的实例对象。
	ConcreteCreator:具体的创建器对象，覆盖实现Creator定义的工厂方法，返回具体的Product实例。
		
工厂方法模式
工厂方法模式 factory Method
Factory Method Factory Method Factory Method

导出数据的应用框架

		